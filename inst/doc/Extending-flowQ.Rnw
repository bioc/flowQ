% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
%\VignetteIndexEntry{Basic Functions for Flow Cytometry Data}
%\VignetteDepends{flowViz}
%\VignetteKeywords{}
%\VignettePackage{flowViz}
\documentclass[11pt]{article}

\usepackage{times}
\usepackage{hyperref}
\usepackage[authoryear,round]{natbib}
\usepackage{times}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{amsmath}

\textwidth=6.2in
\textheight=8.5in
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\code}[1]{{\texttt{#1}}}


\title{Extending flowQ: how to implement QA processes}
\author{F. Hahne B. Ellis}

\begin{document}
\maketitle

\begin{abstract}
\noindent \Rpackage{flowQ} provides infrastructure to generate
interactive quality reports based on a unified HTML output. The
software is readily extendable via modules, where each module
comprises a single QA process. This Vignette is a brief tutorial how
to create your own QA process modules.
\end{abstract}

<<loadPackage, echo=false,results=hide>>=
library(flowQ)
@

\section{Installation}
The \Rpackage{flowCore} package can be installed using Bioconductor's
\Rfunction{biocLite} function, making sure that all R dependencies are
met. In addition, the \Rpackage{ImageMagick} library has to be
installed on your system and its binaries have to be available in the
system path. \Rpackage{ImageMagick} can be downloaded from
\url{http://www.imagemagick.org}. On Debian linux systems, the command
\Robject{sudo apt-get install imagemagick} usually works.

\section{Basic idea of \Rpackage{flowQ}'s QA reports}
In \Rpackage{flowCore}, flow cytometry data is organized in
\Rclass{flowFrames} and \Rclass{flowSets}. Usually, a \Rclass
{flowSet} comprises one experiment or one staining panel of one
particular experiemnt. The initial step of all data analysis is
typically a quality assessment (QA) check. Depending on the design of
the experiment, the measurement channels and the biological question,
there are various levels on which QA makes sense and also various
different parameters that have to be checked. 

In \Rpackage{flowQ} we tried to implement a framework that allows to
create consise QA reports for one or several \Rclass{flowSets} and
that is readily extendable using self-defined modules. The general
design of a \Rpackage{flowQ} QA process is:

\begin{itemize}
\item{aggregator:} a qualitative or quantitative value that indicates
  the outcome of a QA process or of one of its subprocesses for one
  single \Rclass{flowFrame} in the set. 
\item{summary graph:} a plot summarizing the result of the QA
  process for the whole \Rclass{flowSet}.
\item{frame graphs} plots visualizing the outcome of a QA process or
  of one of its subprocesses for a single \Rclass{flowFrame} (optional).
\end{itemize}

A single QA process may contain various subprocesses, for instance
looking at each measurement channel in a \Rclass{flowFrame}
separately, and each of these subprocesses may have its own aggregator
and/or graphs. However, one unified aggregator indicating the overall
outcome of the QA process is mandatory.

Abstractions for each of these building blocks are avaible as classes
and for each class there are constructors which will do the dirty work
behind the scenes. All that needs to be provided by the user-defined
QA functions are file paths to the respective plots and lists of
aggregators indicating the outcome (based on cutoff values that have
been computed before. For each of these classes, there are
\Rfunction{writeLine} methods, which create the appropriate HTML
output. The user doesn't have to care about this step, a fully
formated report will be generated when calling the
\Rfunction{writeQAReport} function.

\section{Aggregators}
There are several subclasses of aggregators, all inheriting from the
virtual parent class \Rclass{qaAggregator}, which defines a single
slot, \Rfunarg{passed}. This slot is the basic indicator whether the
\Rclass{flowFrame} has passes the particular quality check. More
fine-grained output can be archived by the following types of
sub-classes (see their documentation for details):

\begin{itemize}
\item{\Rclass{binaryAggregator}:} the most basic aggregator,
  indicating ``passed'' or ``not passed'' by color coding.
    
  \includegraphics[width=8mm]{binary.jpg}
    
\item{\Rclass{discreteAggregator}:} allows for three different states:
  ``passed'', ``not passes'' and ``warn'', also coded by colors. Not
  that ``warn'' will set the \Rfunarg{passed} slot to \code{FALSE}.
    
  \includegraphics[width=12mm]{discrete.jpg}
  
\item{\Rclass{factorAggregator}:} multiple outcome states. The factor
  levels are plotted along with color coding for the overall outcome
  (``passed'' or ``not passed'').
   
  \includegraphics[width=15mm]{factor.jpg}
  
\item{\Rclass{stringAggregator}:} arbitrary character string
  describing the outcome. Font color indicates the overall outcome.
  
    \includegraphics[width=14mm]{string.jpg}
  
  
\item{\Rclass{numericAggregator}:} a numerical value describing the
  outcome. Currently, the value is plotted as a character string, but
  this might change in the future. Font color indicates the overall
  outcome.
  
    \includegraphics[width=8mm]{numeric.jpg}
  
  
\item{\Rclass{rangeAggregator}:} a numerical value within a certain
  range describing the outcome. A horizontal barplot is produced with
  color indicating the overall outcome.
    
  \includegraphics[width=13mm]{range.jpg}

\end{itemize}
  
Aggregator objects can be created using either \Rfunction{new} or the
constructor functions. E.g., the following code creates instances of
each of the six aggregator types:
<<createAggrs>>=
binaryAggregator()
discreteAggregator(2)
factorAggregator(factor("a", levels=letters[1:3]))
stringAggregator("test", passed=FALSE)
numericAggregator(20)
rangeAggregator(10, 0, 100)
@ 

A special class \Rclass{aggregatorList} exists that holds multiple
aggregators, not necessarily of the same type, and this is used for QA
processes with several subprocesses. The constructor takes an
arbitrary number of \Rclass{qaAggregator} objects, or a list of such
objects. This class mainly exists for method dispatch.
<<aggrList>>=
aggregatorList(bin=binaryAggregator(FALSE), disc=discreteAggregator(1))
@ 

\section{Storing images as \Rclass{qaGraph}s}
While aggregators indicate the general outcome of a QA process, or, at
most, a single quantitative value, the amount of information they can
provide is very limited. \Rpackage{flowQ}'s design allows to include
additional diagnostic plots, both on the level of the whole
\Rclass{flowSet} and for each \Rclass{flowFrame} individually. Smaller
bitmap versions of the plots are used for the overview page, and each
image is clickable, opening a bigger vectorized version of the plot
that is better suited for detailed inspection. To take the burden of
file conversion away from the user, the class \Rclass{qaGraph} was
implemented, which stores single images. The class constructor takes
two mandatory arguments: \Rfunarg{fileName} which is a valid path to
an image file (either bitmap or vectorized), and \Rfunarg{imageDir},
which is a file path to the output directory where the image files are
to be stored. If you are planning to place the final QA report on a
web server, you should make sure, that this path is accessable. The
safet solution is to chose a directory below the root directory of the
QA report, e.g., \code{qaReport/images} if the root directory is
/code{qaReport}.

You can control the final width of the bitmap version of the image
through the optional \Rfunarg{width} argument, and empty
\Rclass{qaGraph} objects can be created by setting
\code{empty=TRUE}. During object instantiation, the file type is
detected automatically and the image file will be converted, resized
and copied if necessary.
<<qaGraph>>=
tmp <- tempdir()
fn <- file.path(tmp, "test.jpg") 
jpeg(file=fn)
plot(1:3)
dev.off()
idir <- file.path(tmp, "images")
g <- qaGraph(fn, imageDir=idir)
g
qaGraph(imageDir=idir, empty=TRUE)
@ 

For the special case of QA processes with multiple subprocesses (e.g.,
individual plots for each channel), there is a class
\Rclass{qaGraphList} and an associated constructor, which will take a
character vector of multiple file names. This class mainly exists for
method dispatch and to facilitate batch processing of multiple image
files.

\section{Information for a single frame: class \Rclass{qaProcessFrame}}
All the information of a QA process for a single frame has to be bundled
in objects of class \Rclass{qaProcessFrame}. Again, a constructor
facilitates instantiating these objects; the mandatory arguments of
the constructor are:
\begin{itemize}
\item {\Rfunarg{frameID}:} a unique identifier for the
  \Rclass{flowFrame}. Most of the time, this will be the
  \Rfunction{sampleName} of the frame in the \Rclass{flowSet}. The
  frame will be identified by this symbol in all of the following
  steps and you should make sure that you use unique values, otherwise
  the downstream functions will not work.
\item{\Rfunarg{summaryAggregator}:} an object inheriting from class
  \Rclass{qaAggregator} indicating the overall outcome of the process
  for this frame.
\end{itemize}

 Further optional arguments are:
 
\begin{itemize}
\item{\Rfunarg{summaryGraph}:} an object of class \Rclass{qaGraph}
  providing a graphical summary of the  QA process for this frame. 
\item{\Rfunarg{frameAggregators}:} an object of class
  \Rclass{aggregatorList}. Each aggregator in the list indicates the
  outcome of one single subprocess for this frame, e.g., for every
  individual measurement channel. 
\item{\Rfunarg{frameGraphs}:} an object of class
  \Rclass{qaGraphList}. Each qaGraph in the list is a graphical
  overview over the outcome of one single subprocess for this
  frame. Note that the length of both \Rfunarg{frameAggregators} and
  \Rfunarg{frameGraphs} have to be the same if you want to use
  them. Assuming that you don't want to include images for one of the
  subprocesses, you have to provide empty \Rclass{qaGraph} objects
  (see above). It is not possible to omit aggregators for
  subprocesses, because they are used to link to the repsective
  images.
\item{\Rfunarg{details}:} a list of additional information that you
  want to keep attached to the \Rclass{qaProcessFrame}. For example,
  this can be the values of a quality score that was computed in order
  to decide whether the QA process has passed the requirements. Such
  information can be useful to update aggregators later without
  reproducing the images (e.g., when a cutoff value has been changed).
\end{itemize}
  

\section{The whole QA process: class \Rclass{qaProcess}}
Now that we have all the information for the single frames together,
we can proceed and bundle things up in a unified object of class
\Rclass{qaProcess}. Again, the constructor has a couple of mandatory
arguments:

\begin{itemize}
\item{\Rfunarg{id}:} a unique identifier for this QA process. This
  will be used to identify the process in all downstream functions,
  which will not work unless it really is unique (assuming that you
  want to combine multiple QA processes in one single report).
\item{\Rfunarg{type}:} A character scalar describing the type of the
  QA process. This might become useful for functions that operate on
  objects of class \Rclass{qaProcess} in a type-specific way (e.g.,
  updating agregators).
\item{\Rfunarg{frameProcesses}:} a list of \Rclass{qaProcessFrame}
  objects. You have to make sure that the identifier for each
  \Rclass{qaProcessFrame} is unique and that the length of the list is
  equal to the length of the \Rclass{flowSet}.
\end{itemize}
  
 Further optional arguments are:
 
\begin{itemize}
\item{\Rfunarg{name}:} The name of the process that is used as caption
  in the output.
\item{\Rfunarg{summaryGraph}:} An object of class \Rclass{qaGraph}
  summarizing the outcome of the QA process for the whole
  frame. Although this is mandatory, we strongly recommend including
  such a plot, as it provides a good initial overview.
\end{itemize}

The output of you own QA process function should always be an object
of class \Rclass{qaProcess}, which can be used in the downstream
functions to produce the quality assessment report. Most of the time,
the function would have a structure similar to the following:

\begin{enumerate}
\item iterate over frames to create the \Rclass{qaProcessFrame}
  object, possibly with an additional level of iteration for each
  subprocess (e.g. each channel). Each iteration involves creation of
  at least one \Rclass{qaGraph} and \Rclass{qaAggregator} object.
\item create an \Rclass{qaProcessFrame} object summarizing the process
  for the whole set.
\item bundle things up in a \Rclass{qaProcess} object.
\end{enumerate}

\section{ Quality Assesment of Ungated High Throughput Flow Cytometry Data-using
the flowQ package}

The  advent of high throughput methods has resulted in a large increase in the 
amount of data available from cytometry experiments. This large amount of 
information needs to be summarized and presented in a visually appealing manner
so that the researcher can draw appropriate inferences from the data.

Quality assesment is an important step in the data analysis pipeline
often helping researchers identify differences in samples originating from
conditions that are probably not of biological origin. A quality control criterion
can then be established to give special consideration to these samples or even 
exclude them from further analysis.

In a typical flow cytometry experiment, samples from patients are often divided 
into several aliquots. The aliquots are then stained  with specific stains that 
are selective to antibodies presented by the cell surface. The basis for the quality
control procedure is that cell specific parameters like Forward and Side Scatter 
which are dependent on the cell size and the granularity of the cell respectively
should present similar results across aliquots. Additionally, ceratain flourescent 
dyes utilized in the staining procedure may be replicatd in some of the aliquots. 
Floursence intensities recorded from such dyes are also expected to be similiar
across aliquots. 

Several one and two dimensional methods have been presented  in the flowQ package
that helps users perform quality analysis and generate summary reports.

\subsection{Data preprocessing and transformation}

Our data set involves samples collected from 4 individuals which were then 
split into 8 aliquots.Each aliquot was then stained with a different combination 
of stains.

The first step in the data analysis pipeline involves reading in the cytometry 
data which can be achieved using the \Rfunction{read.FCS} function for FCS files 
or using the \Rfunction{load} function for flow cytometry data that was saved from 
a previous R workspace. In our example, the data file flowData.rda resides in the 
data folder of the flowQ package and can be loaded with the \Rfunction{data} command.

<<Read_Transform,echo=true,results=verbatim>>=
data(qData)
qData[[1]][[1]]
@

The data read into an R session is a \Rclass{list} containing  8 \Rclass{flowSets}, 
each \Rclass{flowSet} corresponding to an aliquot. Each \Rclass{flowSets} contains 
data from four patients. 

The description field off each flowSet contains information regarding the stains
used for each sample. In data sets that do not contain the stain information, the
description field of each \Rclass{flowFrame} needs to be updated with the corresponding
stain information. Description fields for parameters like forward/side scatter and 
Time are to be filled with NA.( The methods \Rfunction{pData} and \Rfunction{parameters}
can be used to update the description field)

The parameters need to be first needs to be transformed for better visualization
of the data. For the dataset, all flow parameters except forware and side scatter 
were transformed using the \Rfunction{asinh} transformation.

<<transformData, echo=true,results=hide,eval=FALSE>>=
tData<-list()
for(i in seq_len(length(qData))){
    wfNew <- workFlow(qData[[i]], name="panel")
    tf <- transformList(colnames(Data(wfNew[["base view"]]))[3:7], asinh,transformationId="asinh")
    add(wfNew, tf)
    tData[[i]] <- Data(wfNew[["asinh"]])
    rm(wfNew)
}
@

A pair wise plot of all parameters for the first \Rclass{flowSet} is shown below

<<Plot1_TransformedData, fig=true, echo=true,eval=FALSE>>=
library(flowViz)
plot(tData[[1]][[1]])
@

\subsection{QA process for boundary values}

A large number of boundary values could possible cause problems during the data 
analysis stage. Since the QA procedure compares the flow parameters for each patient
across the eight aliquots, we have to ensure that the percentage of boundary events
is not significantly high to cause issues with the QA process, especially for  1D 
QA processes which involve estimating the density and KL distances or when a 2D summary 
statistics such as the mean is used.

The \Rfunction{qaProcess.BoundaryPlot} allows the user to quickly visualize the 
percentage of boundary events for each patient in the data set. The output generated
from the function can be written to an html report. Each horizontal panel corresponds
to data for a patient and the vertical divisions displaying the results for a 
particular QA procedure. For each patient, the results from the eight aliquots
are grouped side by side. The function also has a cutoff parameter
allowing the user to flag patient panels that have a large number of events on
the boundary and potentially require filtering.

<<transformBoundaryData, echo=true,results=hide,eval=FALSE>>=
resBoundary <- qaProcess.BoundaryPlot(tData,dyes=NULL,outdir="myDir",cutoff=3,pdf=FALSE)
boundUrl<-writeQAReport(tData[[1]], list(resBoundary), outdir="myDir",pdf=FALSE)
browseURL(boundUrl)
@

A boundary filter can be used to remove events at the boundaries 
for each channel.The transformed data after excluding the boundary events 
is stored as a \Rclass{list} of \Rclass{flowSet}s 

<<BoundaryEvents, echo=true,results=hide,eval=FALSE>>=

createBoundaryFilterList<-function(flowSet){
    len <- length(colnames(flowSet))
    tmp<-fsApply(flowSet,range)
    tmp<-lapply(tmp,function(x){
        x[[colnames(x)[len]]]<-NULL
        x
    })
    res<-lapply(tmp,function(y){
        apply(y,2,function(x){
        # 2*x-extendrange(r=x,0.1)
          c((x[1]+2*.Machine$double.eps),(x[2]-2*.Machine$double.eps))
        })
    
    })
    filtList<-lapply(res,function(x){
            rectangleGate(filterId="boundary",.gate=x)
    }		)	
    return(filtList)
}

boundData<-list()
for(i in seq_len(length(tData))){
    wfNew <- workFlow(tData[[i]], name="panel")
    filtList<-createBoundaryFilterList(Data(wfNew[["base view"]]))
    flt<-filterList(x=filtList,filterId="boundary")
    add(wfNew,flt)
    boundData[[i]] <- Data(wfNew[["boundary+"]])
    rm(wfNew)
    cat(i)
    cat(".")
}
@

\subsection{Data normalization}

When data from different aliquots are compared, shifts in floursecence intensities
can be obeserved for the same flourescence dye. Biologically there should have 
been no differences as the cell types came from a single sample from the patient..
These shifts need to be corrected for before proceeding with any gating.Additionally,
the QA processes for density,ECDF plots etc relies on the distance between
the plots from the same patient to identify patient panels that are potential
outliers. Proper alignment of data from diffferent aliquots is necessary and can be 
done using the \Rfunction{warpSet} function. The function normalizes data 
based on landmarks estimated from high density regions in the data.

The parameters that are duplicated across the aliquots for each patient can be 
identifed using the \Rfunction{locateDuplicatedParameters}. For each floursence
parameter obtained from a patietn,the daata from eight aliquots are normalized 
so that the peaks in flow parameters align up between aliquots.

<<Data Normalization, echo=true,results=hide,eval=FALSE>>=
  library(flowStats)
  patientID=sampleNames(boundData[[1]])
  ls <- length(patientID)
  dupes <- locateDuplicatedParameters(boundData)
  nData<-normalizeSets(flowList=boundData,dupes=dupes[-c(1,2)]) ## ignoring FSC-A, SSC-A
@

\subsection{ECDF plots}

Emperical cumulative distribution function gives the probability that a randomly 
picked sample is less than or equal to its value. ECDF plots can easily reveal 
differences in the distribution of the flowy cytometry parameters although they 
do not reveal much informaton regarding the underlying shape of the distribution.

The \Rfunction{qaProcess.ECDFPlot} produces ECDF plots of the flow cytometry 
parameters. The ECDF plots are grouped by patient so that data from the eight 
aliquots for each patient appear together in one plot, thereby allowing direct
comparision of any differences in their distribution.The cytometer channels from
which the data was obtained are also displayed in the legend.

To identify patient panels that have higher variation amongst the ECDF plots,
sample quantiles were estimated along 256 points. Pairwise KL distances were 
then estimated for each patient and them summed to yield a single distance measure for 
each patient. The sum was then normalized by the maximum value of the sum of the 
KL distances obtained during the QA process for better comparision of the magnitude 
of differences. Univariate outlier detection was performed on the normalized 
distance values to identify patient panels where ecdf plots are different from 
each other.

<<ECDF plots, echo=true,results=hide,eval=FALSE>>=
resECDF <- qaProcess.ECDFPlot(nData,dyes=NULL,outdir="myDir",alpha=0.28,pdf=FALSE)
ecdfUrl<-writeQAReport(nData[[1]], list(resECDF), outdir="myDir",pdf=FALSE)
browseURL(ecdfUrl)
@

\subsection{Density plots}

Density plots reveal useful information regarding the underlying shape of the 
distribution. They describe the probability of a variable being at a specific 
value.

Density plots can be produced by the \Rfunction{qaProcess.DensityPlot} function.
Each panel in the plot produced represents data from a patient. The density data 
for parameters from  each aliquot are represented in a different color. 
Additionally, the channels from which they were aquired are shown in the legend.

For each patient, density values were estimated along 256 equidistant points along
the range of each floursence parameter. For the density values from each patient,
pairwise KL distances between the density data from the aliquots were then computed.
The sum of the pairwise distances for each patient was then normalized to the maximum
value of the sum that was calculated in the data set to yield a number between 0 
and 1. Univariate outlier detection was performed on the normalized 
distance values to identify patient panels where density plots are different from 
the rest of the group.

<<Density plots, echo=true,results=hide,eval=FALSE>>=
resDensity <- qaProcess.DensityPlot(nData,dyes=NULL,outdir="myDir",alpha=0.2)
densityUrl<-writeQAReport(nData[[1]], list(resDensity), outdir="myDir")
browseURL(densityUrl)
@

\subsection{2D Summary statistics}

Two dimensional summaries often provide additional information not available 
in single dimensional approaches such as the denstiy plot as they display information
regarding the consolidated distribution of parameters.Parameters pairs such as 
forward and sideward scatter occur in measurements from all the aliquots.

Statistical measures such as the mean, median etc can be calculated for each 
parameter and can be represented in the form of a scatter plot for each patient.
The summary statistic of the flourence parameter pair from each liquot represents
a point in the scatter plot panel of each patient.

The \Rfunction{2DStatsPlot} generates scatter plots of summary statistics of 
flourescence parameter pairs occuring in each aliquot. Any parameter pairs in an
aliquot that occur in more than once in the \Rclass{list} of \Rclass{flowSets}
can be passed as input to this function.

Two dimensional outlier detection is performed on the scatter plot panels for 
each patient to identify aliquots with the summary statistic measure different
from the rest. The summary plot on the top of the html report shows the an overview
of the selected summary statistic measure for each patient. The outliers are displayed
in red. 

The scatter plot for each parameter pair can also be observed in horizontal
panels for each patient. For each detailed patient panel,the flouresnce channel 
from which the parameter was recorded as well as the aliquot number are displayed 
in the legend. The outlier aliquots are marked with a red dot.

<<2DSummary_statistics, echo=true,results=hide,eval=FALSE>>=
par<-c("FSC-A","SSC-A","CD4","CD8","CD3","HLADr")
resSummary <- qaProcess.2DStatsPlot(nData,dyes=par,outdir="myDir",func=mean,
outBound=0.34,pdf=FALSE)
summaryUrl<-writeQAReport(nData[[1]], list(resSummary), outdir="myDir",pdf=FALSE)
browseURL(summaryUrl)
@

\subsection{Kullback-Leibler distance plots}

The Kullback-Leibler Information between densities f1 and f2 is defined as 

\begin{equation}
\label{eq:test} 
\ KLI=\int \frac{f_{1}(x)}{f_{2}(x)}f_{2}(x) dx
\end{equation}

Density estimation followed by numerical integration can be used to calculate the 
pairwise KL distance between the parameters values for each aliquot to identify 
patient panels that are potentially different from the rest. However such an 
approach may be computationaly intensive, especially for flow 
cytometry data.

An alternative approach is to bin the flouresence data to obtain an estimate of
density. The estimated density values can then be used to compute pair wise KL 
distances for the aliquots from which data was obtained.The aliquots which were not 
stained for a particular parameter are labelled as missing.

The pairewise KL distances are then be visualized by a plot with color 
representation for the distance matrix.  Aliquots that are similar will exhibit
a lower KL distance in the plot generated.

<<KL Distance plots, echo=true,results=hide,eval=FALSE>>=
resKLdist <- qaProcess.KLDistPlot(nData,dyes=NULL,outdir="myDir",alpha=0.05)
klDistURL<-writeQAReport(nData[[1]], list(resKLdist), outdir="myDir")
browseURL(klDistURL)
@


The visualiztion techniques presented in this package provide differnt views of the 
underlying statistical properties of the data. A combination of the visualization 
techniques could help the user identify deviant samples. The visualization tools 
provided by the flowQ package could potentially help identify
samples that are probably not biologically motivated and hence could be further 
investigated before spending time and resources for gating and detailed analysis.

\clearpage
%\bibliography{cytoref}
\end{document}
